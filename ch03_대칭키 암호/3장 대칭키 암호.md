# 3. 대칭키 암호

<br>

## 3.1 개요
>대칭키 암호는 스트림 암호화 블록 암호로 구분됨

### 대칭키 암호
- 암호화화 복호화에 같은 키(비밀키)를 사용하는 방식
- 보낸 사람과 받는 사람이 공통의 비밀키를 미리 공유해야 한다.

### 스트림 암호 (Stream Cipher)
- 전통적인 일회성 암호화 개념이 비슷
- 일회성 암호와 같은 방식으로 키를 긴 비트열로 늘여서 사용
- 일회성 암호처럼 섀넌의 원칙 중 혼돈 이론만 적용
- **A5/1, RC4**

### 블록 암호 (Block Cipher)
- 고전 코드북 암호의 현대 버전
- 블록 암호는 키를 결정하는 특정 코드북과 다양한 다른 코드북 포함
- 블록 암호는 실제 코드북의 전자 버전
- 혼돈과 확산의 원칙을 모두 사용
- **DES, AES, TEA**

<br>

## 3.2 스트림 암호
- 길이가 n 비트인 키 K를 가지며, 이 키를 긴 키 스트림(key stream)으로 늘이고 키 스트림은 평문 P와 XOR 연산하여 암호문 C 생성

$C = P \oplus S$

- 동일한 키 스트림은 XOR 연산을 통해 암호문 C를 평문 P로 복호화하는 데 사용

$P = C \oplus S$

### A5/1
>GMS 통신을 보호하기 위해 개발된 스트림 암호
- 2G GSM 음성 데이터 보호
- 세 개의 LSFR(Linear Feedback Shift Register)를 사용하여 키 스트림 생성
    - X : 19 bit
    - Y : 22 bit
    - Z : 23 bit
- 총 64 bit
- 저전력 하드웨어 최적화

#### A8 알고리즘
- **세션 키 생성**
- 가입자 키($K_i(128 bit)$)와 난수($RAND(128 bit)$)를 이용해 압축함수(COMP128 등) 처리 -> 세션 키($K_c$(64bit)) 출력

#### COMP128 알고리즘
- 가입자 키($K_i(128 bit)$)와 난수($RAND(128 bit)$)를 입력으로 받아 두 값을 붙여 총 256비트의 입력 생성 -> 이를 32개의 8비트로 쪼갬

```
## COMP128 알고리즘 과정
- 총 8라운드로 이루어진 함수
- 각 라운드에서 입력 블록들을 섞어 비선형성 확보

1. 32개의 값과 32개의 Block을 16쌍으로 묶음
2. 각 쌍에 대해 두 입력 값 (a, b)를 가져옴
    2-1. (a, b)를 S-box 같은 비선형 치환 테이블에 통과시켜 두 개의 새로운 값 (a', b')을 생성
    2-2. 총 32개의 값이 새롭게 갱신
3. 라운드가 끝나면 값들을 섞어 다시 배치 -> 이 과정을 8번 반복
4. 8라운드가 끝나면 32개의 값(256 bit)이 나오고, 이중 상위 128bit 사용
```

#### [A5/1 알고리즘 실습](https://github.com/Do-heewan/Information_Security/blob/main/3%EC%A3%BC%EC%B0%A8/A5.py)

<br>

### RC4 알고리즘
- 소프트웨어 구현에 최적화
- 각 단계에서 키 스트림 바이트를 생성
- 256 바이트 크기의 상태 배열 S를 이용

<br>

## 3.3 블록 암호
- 고정된 길이 (ex. 128bits)의 블록에 대해 가역 변환 (E_K)를 제공
    - 반복되는 블록 암호는 평문을 **고정 크기 블록**으로 나누고 고정 크기 블록 단위로 암호문 생성
    - 함수 F를 반복 수행하여 평문에서 암호문 생성
    - 함수 F는 이전 라운드의 출력과 키에 의해 결정됨
- 긴 메세지는 운용 모드 (CTR, CBC, GCM)등 처리
- 암호화, 소프트웨어 최적화

### 파이스텔 암호
> 함수 F의 특정 회전과 무관하게 복호화를 할 수 있는 것이 특징

### DES(Data Encryption Standard) 알고리즘
- IBM 루시퍼 암호 -> DES의 뿌리
- NBS가 상업용 표준 암호성 필요성을 인식

```
## DES 알고리즘
- 입력 64비트
- 출력 64비트
- 키 64비트 (56비트 + 패리티 8비트)

파이스텔 구조를 따르며 최종 암호문은 (R_16, L_16)
```

<br>

### AES (Advanced Encryption Standard) 알고리즘
- DES의 한계 : 56비트 키 -> Brute-Force에 취약 / 3DES : 보안 향상, 성능 저하
- 파이스텔 구조를 따르던 DES에서 치환 순열(SPN, Subsitution Permutation Network)을 활용하는 AES 채택
- 블록 암호이지만 파이스텔 암호는 아님 -> AES를 복호화하려면 AES의 연산 과정을 역으로 수행할 수 있어야 함

#### AES 고려 사항
- 128 비트 크기 고정
- 키 길이 : 128, 192, 256 세 비트의 키 길이 사용
- 각 라운드수 : 10, 12, 14
- 상태(State)는 128비트를 4x4 바이트 행렬로 표현
- 각 라운드는 3개의 층, 4개의 함수로 구성
    - Bytesub
    - Shiftrow
    - Mixcolumn
    - AddRoundKey

<br>

### TEA(Tiny Encryption Algorithm)
>아주 단순한 블록 암호
- 64비트 블록 길이, 128비트 키 사용
- 모든 연산은 모듈로 연산 $2^{32}$ -> 32비트 이상은 자동 제거

```
## TEA 알고리즘
- 파이스텔 구조와 유사 - 좌우 32비트로 나누어 연산
- 각 라운드는 다음의 연산으로 구성
    - 덧셈 ($mod 2^{32$})
    - XOR
    - 비트 시프트 (<<, >>)
- 32 라운드 (64 Feistel step) 권장
- Delta를 이용해 매 라운드마다 변화 보장
```

<br>

### 블록 암호 모드
>임의 접근이 필요할 때 사용
- 기밀성을 위한 블록 암호 방식
    - 데이터를 암호화해서 불안정한 채널에서 전송될 수 있도록 하는 것

#### ECB 모드
- 전자 코드북 모드
- 각 블록을 독립적으로 같은 키로 암호화
- 구현이 간단, 병렬 처리 가능
- 하지만 같은 평문 블록과 같은 암호문 블록을 사용하면 패턴이 그대로 드러남 -> 공격자가 암호문으로 부터 평문을 추정하는 것이 어렵지 않다

#### CBC 모드
- 이전 암호문 블록을 현재 평문 블록과 XOR 연산 후 암호화

$C_i = E(P_i \oplus C_{i-1}, k)$

$P_i = D(C_i, k) \oplus C_{i-1}$

- 암호 블럭 연결 모드
- 동일한 평문이 동일한 암호문을 생산하지 않는 것이 장점, 같은 평문 블록이어도 앞 블록의 암호문에 따라 결과가 달라짐 -> 패턴 숨김
- 직렬적 구조 -> 병렬화가 어려움 -> 성능 저하

#### CTR 모드
- 블록 암호로 부터 스트림 키를 만들어 평문과 XOR 연산

$C_i = P_i \oplus E(IV + i, K)$

$P_i = C_i \oplus E(IV + i, K)$

- EBC, CBC와 달리 블록 암호를 스트림 암호처럼 사용
- 병렬 처리 가능 -> 빠르고 효율적
- IV 관리가 매우 중요 (재사용시 치명적 보안 취약점)

<img width="1163" height="333" alt="Image" src="https://github.com/user-attachments/assets/6dff4891-fca5-493b-a162-aa6fe6e1f5f9" />

<br>

## 3.4 무결성

### 기밀성과 무결성
- 기밀성 : 비인가자가 읽는 행위를 방지하는 것
- 무결성 : 비인가자가 쓰는 행위를 탐지하는 것

### 메세지 인증 코드 (MAC, Message Authentication Code)
- 데이터 무결성을 보장하기 위해 블록 암호 사용
- MAC는 CBC 암호화에서 거의 언제나 마지막 블록까지 전파된다는 점을 이용 -> 무결성
- 효율성을 위해 데이터를 CBC 모드로 단 한번 암호화 후 기밀성과 무결성 보호를 둘 다 가지는 것이 유용함

<br>

## 3.5 양자 컴퓨터와 대칭 암호
### 양자 컴퓨터
- 강력한 컴퓨터를 만들기 위해 양자역학의 특징을 이용하는 것
- 선택 문제에 대한 엄청난 성능 증가 가능
- 양자 컴퓨팅을 위한 특별한 알고리즘 필요

### 양자 컴퓨터란?
- 기존의 디지털 컴퓨터는 0과 1 두 개의 값만을 이용해 데이터를 표현.
- 양자 컴퓨터는 Q-bit을 이용하여 0과 1을 동시에 표현할 수 있다.
    - Q-bit 끼리 얽히면 다수 큐비트가 동시에 다양한 계산을 병렬적으로 수행 가능

### 양자 컴퓨터와 대칭 암호 보안
- 1996년, 일반 대칭 암호 공격에 사용 가능한 최선의 양자 알고리즘 -> Grover 알고리즘.
- 양자 컴퓨팅은 공개키 암호 시스템에 위협적이다.
- 대칭 암호에는 상대적으로 덜 위협적

### Grover 알고리즘
- 기존 컴퓨터에서 n비트 탐색 시 $2^n$번의 시도 필요하였지만, 양자 컴퓨터에서 Grover 알고리즘을 적용하면 $2^{n/2}$번 시도로 줄어듬

